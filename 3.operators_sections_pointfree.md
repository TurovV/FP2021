## 3. Операторы и их сечения в Haskell. Бесточечный стиль.
# операторы
* Оператор — это комбинация из одного или более символов
```
! # $ % & * + . / < > ? @ ^ | - ~ = \ :
```
* Все операторы бинарные и инфиксные 
(кроме унарного префиксного минуса, который всегда ссылается на Prelude.negate).
* Операторы, начинающиеся на двоеточие, должны быть конструкторами данных.
### пример:
```haskell 
a *+* b = a ^ 2 + b ^ 2
```

``` 
GHCi> 3 *+* 4  
25
```
* Операторы могут определяться и использоваться в префиксном (функциональном) стиле.
* Функции могут определяться и использоваться в инфиксном (операторном) стиле.

### пример:
```haskell
(**+**) a b = a ^ 3 + b ^ 3
x `plusminus` y = (x + y, x - y)
```

* Инфиксные операторы требуют определения
  * приоритета: какой оператор из цепочки выполнять первым;
  * ассоциативности: какой оператор из цепочки выполнять первым при равном приоритете.
* Если не заданы, присваивается **infixl 9**.
* Можно задать приоритет и ассоциативность функций и операторов 
с помощью объявлений **infixl**, **infixr** или **infix**.

### пример:
```haskell
infixl 6 *+*, **+**
infix 5 `plusminus`
```

Для стандартных операторов:
```haskell
infixl 9 !!
infixr 9 .
infixr 8 ^, ^^, **
infixl 7 *, /, `quot`, `rem`, `div`, `mod`
infixl 6 +, -
infixr 5 ++, :
infix  4 ==, /=, <, <=, >=, >, `elem`, `notElem`
infixr 3 &&
infixr 2 ||
infixl 1 >>, >>=
infixr 1 =<<
infixr 0 $, $!, `seq`
--применение имеет десятый приоритет
```
В GHCi можно подглядеть, набрав **:info (&&)**

оператор **$** -- оператор применения с наименьшим приоритетом
```haskell
f (g x) ≡ f $ g x
```
оператор **&** -- разворачивает **$**
```haskell
infixl 1 & -- Data.Function
(&) :: a -> (a -> b) -> b
(&) = flip ($)
```
### пример
```haskell
GHCi> (+12) $ (*10) $ 3
42
GHCi> 3 & (*10) & (+12)
42
```
оператор **(.)** -- композиция функций
```haskell
infixr 9 .
(.) :: (b -> c) -> (a -> b) -> a -> c
f . g = \ x -> f (g x)
```
### пример
```haskell
GHCi> (^2) . (+5) $ 1
36
```

# сечения
Операторы на самом деле просто функции и, поэтому, допускают частичное применение.
Сечения (sections) — синтаксический сахар для частичного применения как к левому, так и к правому аргументу.
Скобки обязательны!
### пример
Левое сечение:
``` haskell
(2 *+*) ≡ (*+*) 2 ≡ \y -> 2 *+* y
```
Правое сечение:
``` haskell
(*+* 3) ≡ \x -> x *+* 3
```
Еще пример:

```haskell
GHCi> :t (!!)
(!!) :: [a] -> Int -> a
GHCi> :t (!! 0)
(!! 0) :: [a] -> a
```
## Бесточечный стиль
Без точки применения, то есть без аргумента функции.
### примеры
```haskell
lg x = logBase 2 x -- комбинАторное определение
lg' = \x -> logBase 2 x -- определение через лямбды
lg'' = logBase 2 -- бесточечный стиль
```
```haskell
 sum' xs = foldr (+) 0 xs
 sum = foldr (+) 0 -- бесточеченый стиль
```
```haskell
f x = inc x
f = inc -- бесточечный стиль
```
```haskell
 foldr f e . map g == foldr f' e
      where f' a b = f (g a) b

 foldr f e . map g == foldr (f . g) e -- бесточечный стиль 
```


