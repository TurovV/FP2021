# 22. Ввод-вывод в чистых языках. Монада IO. Взаимодействие с файловой системой.

[презентация](https://wiki.compscicenter.ru/images/1/18/Fpc11HSE2021.pdf) </br>
Последний раздел в презентации.

Лирическое отступление: если мы уже знаем, что такое монада `State`, то мы можем вместо ячейки памяти в неё "подсунуть" консоль, получив таким образом монаду ввода-вывода.

## Ввод-вывод в чистых языках. Монада IO.

В Хаскелле (как и в любом чистом языке) мы не можем просто так взять и написать функцию 
```haskell
getCharFromConsole :: Char
```
потому что она всегда должна будет возвращать одно и то же значение. Для того, чтобы это обойти мы "запихиваем" весь внешний мир в некоторый тип `RealWorld`, тогда в зависимости от разных состояний входа, то есть от разных состояний внешнего мира, мы можем выводить разные результаты, меняя при этом состояние мира (очен феласофске, очен праваславна).

```haskell
getCharFromConsole :: RealWorld -> (RealWorld, Char)
```
При этом доступ к значениям типа `RealWorld` должен быть ограничен. `RealWorld` у нас некоторый волшебный тип ("Deeply Magical"), в том смысле, что пользователь не может его как-то анализировать, он засунут внутрь монады `IO` и не экспортируется, то есть программист не имеет к нему доступа. И это хорошо, так как мы не можем один и тот же `RealWorld` использовать два раза. Значение типа `IO` это вычисление, которое при выполнении может осуществлять действие ввода-вывода. (при вычислении монада `IO` может обращаться к консоли либо на чтение, либо на запись)

```haskell
newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #)) --реализация в GHC
```
 Базовые функции консольного воода-вывода:
 ```haskell
 --ввод
getChar     :: IO Char          -- считывает один char
getLine     :: IO String        -- считывает всё из консоли до символа новой строки
getContents :: IO String        -- считывает весь консольный буффер

--вывод                             -- значений нет, эффект - запись в консоль
putChar     :: Char -> IO ()            -- выводит один char
putStr      :: String -> IO ()          -- выводит строку
putStrLn    :: String -> IO ()          -- выводит строку с символом возврата каретки
print       :: Show a => a -> IO ()     -- выводит любой тип данный, который может быть 
                                            -- преобразован в строку с помощью show

--ввод-вывод
interact    :: (String -> String) -> IO ()  
-- в неё передают некоторую чистую функцию, Interact читает всё с консоли, передаёт всё в эту
-- чистую функцию, обрабатывает и результат обработки пишет на консоль
 ```

 Когда мы один раз зашли в монаду `IO`, то из неё уже выйти, как из других монад, нельзя, поэтому надо разделять, где мы работаем с вводом-выводом, а где нет и для этого и нужна функция `interact`.

 Для того, чтобы получить значения ввода, нужно в какой-нибудь другой монаде в, например, `do`-нотации сделать подобное:
```haskell
main = do                           -- main имеет тип монады IO (main должен иметь тип IO ())
    putStrLn "What is your name?"   -- вывод
    name <- getLine                 -- ввод, получим в переменной name переданную строку
    putStrLn $ "Nice to meet you, " ++ name ++ "!"

-- это то же самое, что и 

main =                          
    putStrLn "What is your name?" >>
    getLine >>= \name ->            -- в монаде IO перегружен bind, так что образуется линейная
                                        -- цепочка и каждый эффект происходит ровно 1 раз
    putStrLn $ "Nice to meet you, " ++ name ++ "!"
```
Так же в районе 32-33 слайда в презентации рассказываются про то, как сделать из `getChar` саммоу `getLine` и как из `putChar` сделать `putStr`.

## Взаимодействие с файловой системой.

Файловый ввод-вывод похож на сишный, как бы странно это не звучало. Экспортируется из `System.IO`. Важно, что как и всё в Хаскеле, работа с файлами тоже ленивая.

```haskell
-- модификатор, с которым открывают файл
--            на чтение| на запись | добавить в конец | всё сразу
data IOMode = ReadMode | WriteMode | AppendMode | ReadWriteMode 
    deriving (Eq, Ord, Ix, Enum, Read, Show)

type FilePath = String      -- путь к файлу это просто строка

data Handle = ...           -- тип данных, в котором хранится файловый дескриптор, чтобы 
                            -- указывать в других функциях, с каким файлом мы работаем

-- Основные функции для работы с файлами:

openFile :: FilePath -> IOMode -> IO Handle     -- по пути к файлу и режиму работы с ним 
                                                -- получаем хэндл (дескриптор), чтобы потом мочь
                                                -- с эитм файлом что-то делать

hPutChar :: Handle -> Char -> IO ()             -- записать в файл Char
hPutStr :: Handle -> String -> IO ()            -- записать в файл String
hPutStrLn :: Handle -> String -> IO ()          -- записать в файл String с возвратом каретки
hPrint :: Show a => Handle -> a -> IO ()        -- записать в файл произвольный объект, у 
                                                -- которого есть метод show

hGetContents :: Handle -> IO String             -- получить всё содержимое файла в виде строки

hClose :: Handle -> IO ()                       -- закрыть файл с нужным дескриптором

withFile :: FilePath -> IOMode -> (Handle -> IO r) -> IO r
-- принимает имя файла -- режим -- функцию, которая принимает дескриптор и по нему делает любые
        -- действия ввода-вывода -- затем withFile открывает файл, делает что описано в функции
        -- и закрывает файл
        -- сделано типа чтобы не следить и не открывать/закрывать файлы руками, так как сложннаа
```
Так же есть система обработки ошибок работы с вводом выводом, но тут про неё вроде рассказывать не надо, это, наверное, надо рассказать там, где про `try` и `catch` рассказывается.

```haskell
-- пример файлового ввода-вывода
main = do
    -- работа с файлом
    let txt = "Some text"
    handle <- openFile "Test.txt" WriteMode
    hPutStrLn handle tst
    hClose handle

    -- работа с консолью
    putStrLn "Hit any key to continue..."
    ignore <- getChar

    -- использование withFile
    withFile "Test.txt" ReadMode $
        \h -> hGetContents h            -- из-за ленвости файл проччитается в переменную только
        -- тогда, когда с ней произойдёт необратимое действие, например вывод в консоль. Если же
        -- вообще ничего с переменной потом не делать, то и читать ничего не будет
        -- Если бы было take 10 от строки, то и прочиталось бы из файла тоже только 10 символов
        -- но если файл закроется, а мы попросим ещё take 20 например, то произойдёт ошибка
        -- так как переменная строки теперь будет не валидна
        >>= putStrLn
        -- читает содержимое файла и выводит в консоль

    -- работа с консолью
    putStrLn "Hit any key to continue..."
    ignore <- getChar   
    return ()
```
*что такое безумие?*</br>
Ленивый ввод-вывод в файлах это хорошо, когда у нас одноклиентское приложение. Если же у нас сервер и он многопоточный, то использование ленивого ввода-вывода это безумие. (с) Москвин. </br>
Что там где произошло отследить будет практически невозможно, поэтому если вам хочется написать сервер, а это можно сделать на Хаскеле, то надо использовать библиотеку с энергичным `IO`, а не ленивым `IO`. 
